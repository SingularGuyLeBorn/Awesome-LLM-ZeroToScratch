# 项目环境搭建指南 (保姆级教程)

## 概述

本文档旨在提供一个**确定性、可复现、高效率**的 Python 环境搭建流程。我们拒绝任何“魔法”或“玄学”般的安装过程，这里的每一步都有其清晰的意图和理由。

我们遵循“基础设施即代码”的理念，通过 `requirements.txt` 和 `setup.sh` 两个核心文件，将环境的构建过程完全自动化。这解决了以下痛点：
- **环境不一致**：确保每个开发者/服务器的环境 100% 相同。
- **网络问题**：解决在国内服务器上（如 AutoDL）安装大型包（如 PyTorch, flash-attn）时常见的超时和速度慢问题。
- **手动操作繁琐**：实现一键式搭建，告别繁琐的手动 `pip install`。

## 文件说明

1.  **`requirements.txt`**: 这是一个版本锁定的依赖清单。它定义了项目运行所需的所有 Python 包及其精确版本，是环境可复现性的基石。
2.  **`setup.sh`**: 这是我们的核心自动化脚本。它会读取 `requirements.txt` 并以最稳健、最高效的方式完成所有包的安装。

## 如何使用？

1.  **准备 Conda 环境**:
    ```bash
    # 创建一个名为 awesome-llm-env 的新环境，使用 Python 3.10
    conda create -n awesome-llm-env python=3.10 -y

    # 激活这个新环境
    conda activate awesome-llm-env
    ```

2.  **运行安装脚本**:
    将 `requirements.txt` 和 `setup.sh` 放在项目根目录，然后执行以下命令：
    ```bash
    # 赋予脚本执行权限
    chmod +x setup.sh

    # 执行脚本，开始全自动安装
    ./setup.sh
    ```
    现在，请坐和放宽，脚本会处理好一切。

## 可选用法：不依赖 `requirements.txt` 的方式

如果您不想维护一个 `requirements.txt` 文件，或者想在一个命令中看到所有需要安装的包，可以使用下面这条命令来替代 `setup.sh` 中的第三步 (`uv pip install -r requirements.txt ...`)。

这条命令会一次性安装**除 `flash-attn` 外**的所有核心依赖。

```bash
# 定义镜像参数
UV_MIRROR_ARGS="--extra-index-url [https://pypi.tuna.tsinghua.edu.cn/simple](https://pypi.tuna.tsinghua.edu.cn/simple) --extra-index-url [https://download.pytorch.org/whl/cu121](https://download.pytorch.org/whl/cu121)"

# 一键安装所有核心包
uv pip install \
    torch==2.3.0 \
    transformers==4.41.2 \
    datasets==2.19.0 \
    accelerate==0.30.1 \
    tokenizers==0.19.1 \
    deepspeed==0.14.2 \
    peft==0.10.0 \
    bitsandbytes==0.43.1 \
    wandb==0.17.0 \
    sentencepiece==0.2.0 \
    fasttext-langdetect==1.0.5 \
    pyyaml==6.0.1 \
    ruff==0.4.4 \
    $UV_MIRROR_ARGS
````

> **注意**：即使使用这条命令，后续安装 `flash-attn` 的步骤（第4步和第5步）仍然是必需的，因为它的安装方式比较特殊。
>
> **权衡利弊**:
>
>   - **优点**: 命令自包含，不依赖外部文件。
>   - **缺点**: 当依赖项很多时，命令会变得很长，不方便维护和更新。
>
> 我们依然推荐使用 `requirements.txt` 的方式，因为它更清晰，更易于管理。

## `setup.sh` 脚本详解

我们的脚本每一步都经过精心设计，以下是其工作原理和原因。

### 第1步: 验证并安装核心工具

  - **做什么**: 检查 `pip`, `uv`, `aria2c` 这几个关键命令是否存在。如果不存在，则通过 `apt-get` 自动安装。
  - **为什么**: 这保证了脚本自身的健壮性。我们不能假设服务器上预装了所有我们想用的工具。通过自动安装缺失的依赖，脚本可以在一个最小化的系统上“冷启动”。

### 第2步: 安装 `uv`

  - **做什么**: 使用 `pip` 安装 `uv`。`uv` 是一个用 Rust 编写的、极速的 Python 包管理器。
  - **为什么选 `uv`**:
      - **速度**: `uv` 在解析和安装依赖时，比 `pip` 和 `conda` 快几个数量级。
      - **现代**: 它是专门为现代 Python 项目设计的，能更好地处理复杂的依赖关系。
  - **为什么用 `pip` 装 `uv`**: 这是一个“鸡生蛋，蛋生鸡”的问题。我们用系统自带的 `pip` 来安装我们更先进的工具 `uv`，后续所有操作都将由 `uv` 接管。

### 第3步: 安装核心依赖

  - **做什么**: 使用 `uv` 安装 `requirements.txt` 中的所有包。在我们的 `requirements.txt` 中 `flash-attn` 已被注释掉。
  - **为什么**:
      - **使用镜像 (`--extra-index-url`)**: 我们同时指定了清华大学的 PyPI 镜像和 PyTorch 官方的 CUDA-specific 镜像。这极大地加速了所有包（尤其是 PyTorch 家族）的下载速度，解决了网络瓶颈。
      - **特殊处理 `flash-attn`**: 这是整个流程的**关键经验**。`flash-attn` 是最容易出问题的包，因为它要么需要本地编译，要么需要下载一个巨大的预编译包。将其与普通包一起安装会增加失败的风险。我们把它拎出来单独处理。

### 第4步: 稳健地下载 `flash-attn`

  - **做什么**: 不直接用 `uv` 安装 `flash-attn` 的 URL，而是先使用专业下载工具 `aria2c` 将其 `.whl` 文件下载到本地。
  - **为什么选 `aria2c`**:
      - **多线程下载**: `aria2c` 可以使用多个连接同时下载一个文件，能将下载速度压榨到极致。
      - **断点续传**: `wget -c` 或 `aria2c -c` 都支持这个功能。如果因为网络波动导致下载中断，下次运行时会自动从上次的位置继续，而不是从零开始。这是应对不稳定网络的“杀手锏”。
  - **为什么选择预编译包**: 我们直接指定了一个与我们环境（CUDA 12.x, PyTorch 2.3, Python 3.10）匹配的预编译 `.whl` 文件。这让我们**完全跳过了**在服务器上缓慢且容易出错的本地编译过程，是稳定性和速度的双重保障。

### 第5步: 本地安装 `flash-attn` 并清理

  - **做什么**: 使用 `uv` 从刚刚下载到本地的 `.whl` 文件进行安装，然后删除该文件。
  - **为什么**:
      - **速度和可靠性**: 因为文件已经在本地磁盘，安装过程不再涉及任何网络I/O，所以它会**瞬间完成**，并且 100% 不会失败。
      - **保持整洁**: 安装完成后，`.whl` 安装包就没用了，及时删除可以保持项目目录的干净。

通过以上设计，这个 `setup.sh` 脚本不仅能完成任务，还能优雅地处理我们之前遇到的所有棘手问题，真正做到了一键部署。
